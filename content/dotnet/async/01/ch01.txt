## 第 1 章：非同步程式設計和多執行緒基礎

本章涵蓋：

* 多執行緒簡介
* 非同步程式設計簡介
* 非同步程式設計與多執行緒的結合

作為軟體開發人員，我們經常努力使應用程式更快、更靈敏、更高效。一種方法是使計算機能夠同時執行多項任務，最大限度地利用現有的 CPU 核心。兩種常用的技術是多執行緒和非同步程式設計。

**這兩種技術都可以有效地創建響應式客戶端應用程式或處理少量客戶端的伺服器。但當它們結合在一起時，可以極大地提升效能，允許伺服器同時處理數千個客戶端。**

在本章中，我們將討論多執行緒和非同步程式設計是什麼，以及為什麼它們很重要。在本書的其餘部分，我們將討論如何在 .NET 和 C# 中正確使用它們，特別關注 C# 的 async-await 功能。我們將學習這些技術如何工作，討論常見的陷阱，並了解如何正確使用這些技術。

### 1.1 什麼是多執行緒？

在開始討論 async-await 之前，我們需要了解什麼是多執行緒，什麼是非同步程式設計，我們將通過 Web 伺服器和披薩來進行說明。我們將從披薩開始（因為它比 Web 伺服器更美味）。在外賣店製作披薩的過程如下：

1. 廚師收到訂單。
2. 廚師進行製作 - 拿出預先準備好的麵團，塑形，放上醬汁、奶酪和配料。
3. 廚師將披薩放入烤箱並等待烘烤（這是最長的部分）。
4. 廚師從烤箱中取出披薩，切片，裝盒，並交給送貨員。

類似地，Web 伺服器處理請求的過程如下：

1. 伺服器收到請求。
2. 伺服器從磁碟讀取檔案（這是最長的部分）。
3. 伺服器進行一些其他處理（例如打包檔案內容）。
4. 伺服器將其發送回瀏覽器。

在本章的大部分內容中，我將忽略第一步和最後一步，因為在大多數後端 Web 框架（包括 ASP.NET 和 ASP.NET Core）中，它們是由框架處理的，而不是由我們的程式碼處理的。我們將在本章末尾簡要討論它們。圖 1.1 向我們展示了 Web 請求過程：

圖 1.1 單執行緒，單請求流程

現在回到披薩。在最簡單的版本中，廚師將按順序執行步驟，在開始下一個披薩之前完全完成一個披薩。當披薩在烤箱中烘烤時，廚師將只是站在那裡盯著烤箱什麼也不做（這是完全同步的單執行緒版本的過程）。

在 Web 伺服器領域，廚師是 CPU。在這個單執行緒的 Web 伺服器中，我們有簡單的程式碼來執行完成 Web 請求所需的操作，並且當從磁碟讀取檔案時，CPU 被凍結而什麼也不做（實際上，作業系統會在發生這種情況時暫停我們的執行緒，並將 CPU 交給另一個程式，但從我們的程式角度來看，它看起來像是 CPU 被凍結了）。

這個版本的過程有一些優點，它簡單易懂。你可以查看廚師目前正在做哪一步，並確切地知道我們在這個過程中的位置。因為從來沒有兩件事同時發生，所以不同的工作不會互相干擾。最後，這個版本需要的空間最少，並且在任何時候使用的資源都更少，因為我們一次只處理一個 Web 請求（或披薩）。

這個單執行緒同步版本的過程顯然是浪費的，因為廚師/CPU 在披薩在烤箱中烘烤時（或者從磁碟檢索檔案時）大部分時間都什麼也不做，並且，如果我們的披薩店沒有倒閉，我們會比我們能準備好它們的速度更快地收到新訂單。

因此，我們希望廚師同時製作多個披薩。一種方法可能是帶一個計時器，讓計時器每隔幾秒鐘響一次。每次計時器響起時，廚師就會停止他們正在做的任何事情，並記下他們停止時做了什麼。然後，廚師將開始製作一個新的披薩或繼續製作一個之前停止的披薩（忽略烤箱中未準備好的披薩），直到計時器下次響起。

**可能會導致執行緒阻塞的操作被稱為阻塞操作。所有檔案訪問和網路訪問操作都是阻塞的，以及與 CPU 和記憶體以外的任何東西通信的任何其他操作，此外，所有等待另一個執行緒的操作都可能會阻塞。**

回到披薩店，除了我們在不同披薩之間切換所花費的時間之外，還有廚師需要的所有資訊，以便回到他們切換之前完全相同的地方。在我們的軟體中，每個執行緒，即使是那些沒有運行的執行緒，也會消耗一些記憶體，所以，雖然可以創建大量執行緒，每個執行緒都執行一個阻塞操作（所以它們大部分時間都被阻塞並且不消耗 CPU 時間），但這是浪費記憶體的。隨著我們增加執行緒數量，它會變慢，因為我們必須管理所有執行緒，並且在某個時候，我們要么花費太多時間管理執行緒而沒有完成任何有用的工作，要么只是耗盡記憶體並崩潰。

即使有所有這些低效率，多執行緒的廚師，像瘋子一樣從一個披薩跳到另一個披薩，除非我們遇到無法進展或崩潰的情況（我知道，廚師不能崩潰，沒有比喻是完美的），將在相同的時間內製作更多的披薩，主要因為之前的單執行緒廚師在披薩在烤箱中烘烤時大部分時間都在等待。

如圖 1.2 所示，因為我們只有一個 CPU 核心（我知道現在每個人都有多核 CPU，我們很快就會討論多核 CPU），我們不能真正同時做兩件事。所有“處理”部分都依次發生，並且不是真正的並行 - 然而，CPU 可以并行地等待任意多次。這就是為什麼我們的多執行緒版本在比單執行緒版本處理兩個請求所花費的時間少得多的時間內處理了三個請求的原因。

圖 1.2 單執行緒與多執行緒處理多個請求

如果你仔細觀察圖 1.2，你會發現，雖然單執行緒版本更快地處理了第一個請求，但多執行緒版本在單執行緒版本設法完成第二個請求之前就完成了所有三個請求。這向我們展示了多執行緒的巨大優勢，它在涉及等待的情況下可以更好地利用 CPU。它也顯示了我們付出的代價，在每一步都有一點額外的開銷。

回到披薩店，我們忽略了一個常識性的解決方案。廚師應該製作一個單一的披薩，不要像瘋子一樣停下來切換到其他披薩，但是，當披薩在烤箱中時，也許只是，你知道，開始製作下一個披薩，而不要只是坐在那裡盯著烤箱。稍後，每當廚師完成某件事時，他們可以檢查烤箱中的披薩是否準備好了，如果準備好了，就拿出來，切片，裝盒，並交給送貨員。

這就是非同步程式設計。每當 CPU 需要做一些發生在 CPU 本身之外的事情（例如，讀取檔案）時，它會將作業發送到處理它的組件（磁碟控制器），並要求該組件在完成時通知 CPU。

你也可以清楚地看到，圖 1.4 有點混亂，並且比之前的圖表更難閱讀 - 即使沒有在圖表中指示“第二次處理”步驟依賴於完成讀取操作。使圖表更難理解的是，你無法再看到整個過程；為每個請求完成的工作被分解成部分，而這些部分，與執行緒示例不同，彼此之間沒有連接。
